# Database Management Tutorial

Welcome to the database management tutorial! This guide will teach you how to work with the database in your FastAPI application, from basic operations to advanced features like migrations and search.

---

## What is a Database?

Think of a database like a digital filing cabinet. It stores all your app's information in an organized way:
- **Users**: Account information, profiles, settings
- **Data**: Any information your app needs to remember
- **Relationships**: How different pieces of data connect to each other

---

## Database Features Included

### üóÑÔ∏è Core Database Features
- **PostgreSQL**: Professional-grade database for reliability
- **SQLAlchemy**: Python library for database operations
- **Connection Pooling**: Efficient database connections
- **Migrations**: Version-controlled database changes

### üîç Data Management Features
- **Soft Delete**: Hide data instead of permanently deleting it
- **Search & Filter**: Find data quickly and efficiently
- **Pagination**: Handle large amounts of data
- **Audit Logging**: Track all data changes

### üõ°Ô∏è Data Safety Features
- **Data Validation**: Ensure data is correct before saving
- **Type Safety**: Prevent data type errors
- **Backup Support**: Easy database backups
- **Transaction Support**: Ensure data consistency

---

## Real Example: Add a `bio` Field to User

Let's walk through a real example of adding a `bio` field to the user model, updating the schema, generating a migration, and using the new field via the API.

### 1. Update the SQLAlchemy Model ([app/models/models.py](../../app/models/models.py))
```python
class User(Base, SoftDeleteMixin):
    # ... existing fields ...
    bio = Column(String, nullable=True)
```

### 2. Update the Pydantic Schema ([app/schemas/user.py](../../app/schemas/user.py))
```python
class UserUpdate(BaseModel):
    bio: Optional[str] = None
```

### 3. Generate a Migration
```bash
alembic revision --autogenerate -m "add bio to user"
```

### 4. Example Alembic Migration Output ([alembic/versions/xxxx_add_bio_to_user.py](../../alembic/versions/))
```python
def upgrade():
    op.add_column('users', sa.Column('bio', sa.String(), nullable=True))
def downgrade():
    op.drop_column('users', 'bio')
```

### 5. Apply the Migration
```bash
alembic upgrade head
```

### 6. Use the New Field via API
```bash
curl -X PUT "http://localhost:8000/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"bio": "I love FastAPI!"}'
```

---

## Migration Process Diagram

```mermaid
flowchart LR
  A[Edit Model/Schema] --> B[Generate Migration]
  B --> C[Review Migration File]
  C --> D[Apply Migration]
  D --> E[Database Updated]
```

---

## Making a Database Change (Step-by-Step)

Suppose you want to add a new field (e.g., `bio`) to the User model. Here‚Äôs how you do it:

1. **Add the new field to the SQLAlchemy model** (`app/models/models.py`):
    ```python
    class User(Base, SoftDeleteMixin):
        # ... existing fields ...
        bio = Column(String, nullable=True)
    ```
2. **Update the schema** (`app/schemas/user.py`):
    ```python
    class UserUpdate(BaseModel):
        bio: Optional[str] = None
    ```
3. **Generate a migration**:
    ```bash
    alembic revision --autogenerate -m "add bio to user"
    ```
    - *Autogenerate* is great for most changes, but for complex operations (splitting tables, data migrations), you may want to hand-write the migration for full control.
4. **Review the migration file** (`alembic/versions/xxxx_add_bio_to_user.py`):
    ```python
    def upgrade():
        op.add_column('users', sa.Column('bio', sa.String(), nullable=True))
    def downgrade():
        op.drop_column('users', 'bio')
    ```
5. **Apply the migration**:
    ```bash
    alembic upgrade head
    ```
6. **Test the change**: Use the API or Python shell to confirm the new field works as expected.

> **CI/CD Note:**
> In production, migrations are usually applied automatically as part of your CI/CD pipeline (see deployment docs for details).

---

## Why Generate vs. Hand-Write a Migration?
- **Autogenerate**: Fast, safe for most schema changes (add/remove columns, simple types)
- **Hand-write**: Needed for complex changes (data migrations, renames, splitting tables, custom SQL)
- Always review autogenerated migrations before applying!

---

## Basic Database Operations

### Creating Data (INSERT)

To create a new user:

```python
# Using the API
POST /api/v1/auth/register
{
    "email": "newuser@example.com",
    "username": "newuser",
    "password": "SecurePassword123!"
}

# Using Python code
from app.crud.user import create_user_sync
from app.schemas.user import UserCreate

user_data = UserCreate(
    email="newuser@example.com",
    username="newuser",
    password="SecurePassword123!"
)
new_user = create_user_sync(db, user_data)
```

### Reading Data (SELECT)

To get user information:

```python
# Get current user
GET /api/v1/users/me

# Get user by ID
GET /api/v1/users/{user_id}

# Get all users (with pagination)
GET /api/v1/users?page=1&size=10
```

### Updating Data (UPDATE)

To update user information:

```python
# Update current user
PUT /api/v1/users/me
{
    "username": "newusername"
}

# Change password
POST /api/v1/auth/change-password
{
    "current_password": "OldPassword123!",
    "new_password": "NewPassword123!"
}
```

### Deleting Data (Soft Delete)

The template uses "soft delete" - data is hidden but not permanently removed:

```python
# Request account deletion
POST /api/v1/auth/request-account-deletion

# Confirm deletion (7-day grace period)
POST /api/v1/auth/confirm-account-deletion
{
    "token": "deletion_token_from_email"
}
```

---

## Advanced Database Features

### Search and Filter

The template includes powerful search and filtering capabilities:

```python
# Search users by name or email
GET /api/v1/users?search=john

# Filter by verification status
GET /api/v1/users?is_verified=true

# Combine search and filters
GET /api/v1/users?search=admin&is_superuser=true&page=1&size=20

# Sort results
GET /api/v1/users?sort_by=date_created&sort_order=desc
```

**Available filters:**
- `search`: Text search across multiple fields
- `is_verified`: Filter by email verification status
- `is_superuser`: Filter by admin status
- `oauth_provider`: Filter by login method
- `date_created`: Filter by creation date
- `is_deleted`: Filter by soft-deleted status (admin only)

> **Tip:** Filtering by `date_created` is useful for analytics and reporting. Filtering by `is_deleted` lets you view or restore soft-deleted records (admin endpoints only).

### Pagination

Handle large datasets efficiently:

```python
# Basic pagination
GET /api/v1/users?page=1&size=10

# Response includes pagination info
{
    "items": [...],
    "total": 150,
    "page": 1,
    "size": 10,
    "pages": 15,
    "has_next": true,
    "has_prev": false,
    "links": {
        "next": "/api/v1/users?page=2&size=10",
        "prev": null,
        "first": "/api/v1/users?page=1&size=10",
        "last": "/api/v1/users?page=15&size=10"
    }
}
```

### Audit Logging

Track all data changes automatically:

```python
# Audit logs are created automatically for:
# - User registration
# - Login attempts (success/failure)
# - Password changes
# - Account deletions
# - OAuth logins

# View audit logs (admin only)
GET /api/v1/admin/audit-logs?user_id=123&action=login&page=1&size=50
```

---

## Database Migrations

### What are Migrations?

Migrations are like a version control system for your database. They let you:
- **Track changes**: Keep history of database modifications
- **Roll back**: Undo changes if something goes wrong
- **Collaborate**: Share database changes with your team
- **Deploy safely**: Update production databases without losing data

### Creating a Migration

To add a new field to the User table:

```bash
alembic revision --autogenerate -m "Add phone number to users"

# This creates a file like: alembic/versions/abc123_add_phone_number.py
```

> **Reminder:** Alembic's `autogenerate` will NOT detect changes that only affect indexes, constraints, or some column types. If you add or change an index (e.g., `Index`, `UniqueConstraint`), you must manually edit the migration file to include those changes. Always review autogenerated migrations and add missing operations as needed!

### Running Migrations

```bash
# Apply all pending migrations
alembic upgrade head

# Roll back one migration
alembic downgrade -1

# Check current migration status
alembic current

# View migration history
alembic history
```

### Example Migration

Here's what a migration file looks like:

```python
# alembic/versions/abc123_add_phone_number.py
"""Add phone number to users

Revision ID: abc123def456
Revises: previous_migration_id
Create Date: 2024-01-15 10:30:00.000000

"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    # Add phone_number column to users table
    op.add_column('users', sa.Column('phone_number', sa.String(), nullable=True))

def downgrade():
    # Remove phone_number column if we need to roll back
    op.drop_column('users', 'phone_number')
```

---

## Configuration

### Environment Variables

Set these in your `.env` file:

```env
# Database connection
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# Connection pool settings
DB_POOL_SIZE=20
DB_MAX_OVERFLOW=30
DB_POOL_RECYCLE=3600
DB_POOL_TIMEOUT=30
DB_POOL_PRE_PING=true
```

### Connection Pooling

The template uses connection pooling for better performance:

- **Pool Size**: Number of database connections to keep open
- **Max Overflow**: Additional connections when pool is full
- **Pool Recycle**: How often to refresh connections (1 hour)
- **Pool Timeout**: How long to wait for a connection (30 seconds)
- **Pool Pre-ping**: Test connections before using them

---

## Testing Database Operations

### Using the API

Test database operations through the API:

```bash
# 1. Create a user
curl -X POST "http://localhost:8000/api/v1/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "username": "testuser",
    "password": "TestPassword123!"
  }'

# 2. Login to get access token
curl -X POST "http://localhost:8000/api/v1/auth/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=test@example.com&password=TestPassword123!"

# 3. Get user data
curl -X GET "http://localhost:8000/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# 4. Search users
curl -X GET "http://localhost:8000/api/v1/users?search=test&page=1&size=10"
```

### Using Python Code

Test database operations directly:

```python
from app.database.database import get_db
from app.crud.user import get_user_by_email_sync

# Get database session
db = next(get_db())

# Find user by email
user = get_user_by_email_sync(db, "test@example.com")
print(f"Found user: {user.username}")

# Close database session
db.close()
```

---

## Glossary

- **Schema**: A Pydantic model that defines the shape of data for validation and serialization.
- **CRUD**: Create, Read, Update, Delete (basic database operations).
- **Migration**: A script that changes the database schema (structure).
- **Alembic**: A tool for managing database migrations in SQLAlchemy projects.
- **ORM**: Object-Relational Mapper, a tool that lets you interact with the database using Python classes (e.g., SQLAlchemy).
- **Soft Delete**: Marking a record as deleted without actually removing it from the database.

---

## CRUD Scaffolding CLI

**Generate complete CRUD boilerplate in seconds, not minutes!**

The template includes a powerful CLI tool that automatically generates all the code needed for a new resource: models, schemas, CRUD operations, API endpoints, and tests.

### üöÄ Quick Start

#### Basic Usage

```bash
# Generate a simple Post model
python scripts/generate_crud.py Post title:str content:str is_published:bool
```

This single command generates:
- ‚úÖ SQLAlchemy model with proper fields
- ‚úÖ Pydantic schemas (create, update, response)
- ‚úÖ CRUD operations (create, read, update, delete)
- ‚úÖ FastAPI endpoints with full CRUD
- ‚úÖ Basic test coverage
- ‚úÖ Auto-registration in API router

#### Advanced Usage

```bash
# Generate with soft delete functionality
python scripts/generate_crud.py Post title:str content:str is_published:bool --soft-delete

# Generate with search capabilities
python scripts/generate_crud.py Product name:str price:float description:str --searchable

# Generate with admin integration
python scripts/generate_crud.py Category name:str slug:str --admin --slug
```

### üìã Command Reference

#### Syntax

```bash
python scripts/generate_crud.py <ModelName> <field1:type1> <field2:type2> [options]
```

#### Parameters

- **ModelName**: The name of your model (e.g., `Post`, `Product`, `User`)
- **fields**: Space-separated field specifications in `name:type` format
- **options**: Optional flags to enable additional features

#### Field Types

| Type | SQLAlchemy | Pydantic | Description |
|------|------------|----------|-------------|
| `str` | `String` | `str` | Short text fields |
| `int` | `Integer` | `int` | Integer numbers |
| `float` | `Float` | `float` | Decimal numbers |
| `bool` | `Boolean` | `bool` | True/false values |
| `datetime` | `DateTime` | `datetime` | Date and time |
| `date` | `Date` | `date` | Date only |
| `uuid` | `UUID(as_uuid=True)` | `uuid.UUID` | UUID identifiers |
| `text` | `Text` | `str` | Long text content |
| `json` | `JSON` | `dict` | JSON data |

#### Options

| Option | Description |
|--------|-------------|
| `--soft-delete` | Include soft delete functionality with restoration |
| `--searchable` | Add search and filtering capabilities |
| `--admin` | Include admin panel integration |
| `--slug` | Auto-generate slug field from title |

### üîç What Gets Generated

#### 1. Model File (`app/models/post.py`)

```python
import uuid
from datetime import datetime

from sqlalchemy import Boolean, Column, DateTime, String
from sqlalchemy.dialects.postgresql import UUID

from app.database.database import Base
from app.models.models import SoftDeleteMixin

class Post(Base, SoftDeleteMixin):
    __tablename__ = "posts"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, index=True)
    date_created = Column(DateTime, default=datetime.utcnow, nullable=False)
    title = Column(String, nullable=False)
    content = Column(String, nullable=False)
    is_published = Column(Boolean, default=False, nullable=True)

    def __repr__(self) -> str:
        return f"<Post(id={self.id}, title={self.title}, content={self.content}, is_published={self.is_published})>"
```

**Features:**
- Proper table naming (pluralized)
- UUID primary key with indexing
- Automatic `date_created` timestamp
- Soft delete mixin (if enabled)
- Proper field types and constraints

#### 2. Schema File (`app/schemas/post.py`)

```python
import uuid
from datetime import datetime
from typing import Optional

from pydantic import BaseModel, ConfigDict
from app.utils.pagination import PaginatedResponse

class PostBase(BaseModel):
    title: str
    content: str
    is_published: bool = False

class PostCreate(PostBase):
    title: str
    content: str
    is_published: bool = False

class PostUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    is_published: Optional[bool] = None

class PostResponse(PostBase):
    id: uuid.UUID
    date_created: datetime
    title: str
    content: str
    is_published: bool
    is_deleted: bool = False
    deleted_at: Optional[datetime] = None
    deleted_by: Optional[uuid.UUID] = None
    deletion_reason: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)

class PostListResponse(PaginatedResponse[PostResponse]):
    pass
```

**Features:**
- Base schema for shared fields
- Create schema for new records
- Update schema with optional fields
- Response schema with all fields
- Paginated response wrapper
- Soft delete fields (if enabled)

#### 3. CRUD File (`app/crud/post.py`)

```python
from typing import List, Optional, Union

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import Session

from app.models.post import Post
from app.schemas.post import PostCreate, PostUpdate

# Type alias for both sync and async sessions
DBSession = Union[AsyncSession, Session]

async def get_post_by_id(db: DBSession, post_id: str) -> Optional[Post]:
    if isinstance(db, AsyncSession):
        result = await db.execute(
            select(Post).filter(Post.id == post_id, Post.is_deleted.is_(False))
        )
    else:
        result = db.execute(
            select(Post).filter(Post.id == post_id, Post.is_deleted.is_(False))
        )
    return result.scalar_one_or_none()

async def create_post(db: DBSession, obj: PostCreate) -> Post:
    db_obj = Post(**obj.dict())
    db.add(db_obj)
    if isinstance(db, AsyncSession):
        await db.commit()
        try:
            await db.refresh(db_obj)
        except Exception:
            pass
    else:
        db.commit()
        try:
            db.refresh(db_obj)
        except Exception:
            pass
    return db_obj

# ... more CRUD functions
```

**Features:**
- Hybrid async/sync support
- Proper error handling
- Soft delete filtering (if enabled)
- Type-safe operations

#### 4. Endpoints File (`app/api/api_v1/endpoints/post.py`)

```python
from typing import List

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.crud import post as crud_post
from app.database.database import get_db
from app.schemas.post import PostCreate, PostUpdate, PostResponse, PostListResponse
from app.utils.pagination import PaginationParams

router = APIRouter()

@router.get("", response_model=PostListResponse)
async def list_posts(
    pagination: PaginationParams = Depends(),
    db: Session = Depends(get_db),
) -> PostListResponse:
    """
    List posts with pagination.
    """
    posts = await crud_post.get_posts(
        db=db,
        skip=pagination.skip,
        limit=pagination.limit,
    )
    total = await crud_post.count_posts(db=db)
    
    return PostListResponse(
        items=posts,
        total=total,
        page=pagination.page,
        per_page=pagination.limit,
        total_pages=(total + pagination.limit - 1) // pagination.limit,
    )

# ... more endpoints
```

**Features:**
- Full CRUD endpoints
- Proper HTTP status codes
- Pagination support
- Error handling
- Auto-generated documentation

#### 5. Test File (`tests/template_tests/test_post.py`)

```python
import uuid
from datetime import datetime

import pytest
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from app.models.post import Post
from app.schemas.post import PostCreate

# Test data
test_post_data = {
    "title": "Test title",
    "content": "Test content",
    "is_published": True,
}

def test_create_post(client: TestClient, db: Session):
    """Test creating a post."""
    response = client.post("/api/v1/posts", json=test_post_data)
    assert response.status_code == 201
    data = response.json()
    assert data["title"] == test_post_data["title"]
    assert "id" in data

# ... more tests
```

**Features:**
- Basic CRUD test coverage
- Proper test data setup
- Status code validation
- Response structure validation

### üéØ Real-World Examples

#### Example 1: Blog Post System

```bash
python scripts/generate_crud.py Post title:str content:text is_published:bool author_id:uuid --soft-delete
```

**Generated endpoints:**
- `GET /api/v1/posts` - List all posts
- `POST /api/v1/posts` - Create new post
- `GET /api/v1/posts/{id}` - Get specific post
- `PUT /api/v1/posts/{id}` - Update post
- `DELETE /api/v1/posts/{id}` - Soft delete post

#### Example 2: E-commerce Product Catalog

```bash
python scripts/generate_crud.py Product name:str price:float description:text category_id:uuid stock:int --searchable
```

**Features added:**
- Search by name and description
- Filter by category and price range
- Sort by price, name, or date
- Stock management

#### Example 3: User Management System

```bash
python scripts/generate_crud.py User email:str username:str is_active:bool role:str --admin --soft-delete
```

**Features added:**
- Admin panel integration
- Role-based access control
- User activity tracking
- Bulk operations

### üîß Customization Guide

#### After Generation

1. **Review the generated files** - Understand the structure
2. **Add business logic** - Customize validation and business rules
3. **Add relationships** - Define foreign keys and relationships
4. **Customize endpoints** - Add specific business logic
5. **Enhance tests** - Add more comprehensive test coverage

#### Common Customizations

##### Adding Relationships

```python
# In models/post.py
from app.models.models import User

class Post(Base, SoftDeleteMixin):
    # ... existing fields ...
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    author = relationship("User", back_populates="posts")
```

##### Adding Validation

```python
# In schemas/post.py
from pydantic import Field, field_validator

class PostCreate(PostBase):
    title: str = Field(..., min_length=1, max_length=200)
    content: str = Field(..., min_length=10)
    
    @field_validator("title")
    @classmethod
    def validate_title(cls, v: str) -> str:
        if not v.strip():
            raise ValueError("Title cannot be empty")
        return v.strip()
```

##### Adding Business Logic

```python
# In crud/post.py
async def create_post(db: DBSession, obj: PostCreate, author_id: str) -> Post:
    db_obj = Post(**obj.dict(), author_id=author_id)
    # Add business logic here
    db.add(db_obj)
    # ... rest of function
```

### üöÄ Next Steps After Generation

#### 1. Run Database Migrations

```bash
# Generate migration
alembic revision --autogenerate -m "Add Post model"

# Apply migration
alembic upgrade head
```

#### 2. Test Your Endpoints

```bash
# Run the generated tests
pytest tests/template_tests/test_post.py

# Test manually
curl -X POST "http://localhost:8000/api/v1/posts" \
  -H "Content-Type: application/json" \
  -d '{"title": "My First Post", "content": "Hello World!", "is_published": true}'
```

#### 3. Customize and Extend

- Add authentication to endpoints
- Implement custom business logic
- Add more validation rules
- Create additional endpoints
- Enhance test coverage

### üéâ Benefits

#### Time Savings
- **Before**: 30-60 minutes of manual setup
- **After**: 30 seconds of automated generation

#### Consistency
- All generated code follows established patterns
- Consistent naming conventions
- Standardized error handling
- Uniform API structure

#### Quality
- Type-safe operations
- Proper validation
- Error handling
- Test coverage included

#### Maintainability
- Clear separation of concerns
- Modular architecture
- Easy to extend and modify
- Well-documented code

### üîç Troubleshooting

#### Common Issues

**Import errors after generation:**
```bash
# Make sure you're in the project root
cd /path/to/your/project

# Install dependencies if needed
pip install -r requirements.txt
```

**Migration conflicts:**
```bash
# Reset migrations if needed
alembic downgrade base
alembic upgrade head
```

**Test failures:**
```bash
# Check database connection
# Ensure test database is properly configured
# Review generated test data
```

#### Getting Help

- Check the generated code for syntax errors
- Review the template's existing patterns
- Consult the FastAPI documentation
- Check the test suite for examples

---

## Next Steps

Now that you understand database management and CRUD scaffolding, you can:
1. **Add custom models**: Create new data types for your app
2. **Generate CRUD boilerplate**: Use the scaffolding tool for rapid development
3. **Implement relationships**: Connect different types of data
4. **Add database indexes**: Improve query performance
5. **Set up monitoring**: Track database performance
6. **Create data exports**: Backup and export functionality

The database system is designed to be robust, scalable, and easy to work with. It handles the complex parts so you can focus on your application's features! 