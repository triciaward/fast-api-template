# Database Management Tutorial

Welcome to the database management tutorial! This guide will teach you how to work with the database in your FastAPI application, from basic operations to advanced features like migrations and search.

---

## What is a Database?

Think of a database like a digital filing cabinet. It stores all your app's information in an organized way:
- **Users**: Account information, profiles, settings
- **Data**: Any information your app needs to remember
- **Relationships**: How different pieces of data connect to each other

---

## Database Features Included

### ðŸ—„ï¸ Core Database Features
- **PostgreSQL**: Professional-grade database for reliability
- **SQLAlchemy**: Python library for database operations
- **Connection Pooling**: Efficient database connections
- **Migrations**: Version-controlled database changes

### ðŸ” Data Management Features
- **Soft Delete**: Hide data instead of permanently deleting it
- **Search & Filter**: Find data quickly and efficiently
- **Pagination**: Handle large amounts of data
- **Audit Logging**: Track all data changes

### ðŸ›¡ï¸ Data Safety Features
- **Data Validation**: Ensure data is correct before saving
- **Type Safety**: Prevent data type errors
- **Backup Support**: Easy database backups
- **Transaction Support**: Ensure data consistency

---

## Real Example: Add a `bio` Field to User

Let's walk through a real example of adding a `bio` field to the user model, updating the schema, generating a migration, and using the new field via the API.

### 1. Update the SQLAlchemy Model ([app/models/models.py](../../app/models/models.py))
```python
class User(Base, SoftDeleteMixin):
    # ... existing fields ...
    bio = Column(String, nullable=True)
```

### 2. Update the Pydantic Schema ([app/schemas/user.py](../../app/schemas/user.py))
```python
class UserUpdate(BaseModel):
    bio: Optional[str] = None
```

### 3. Generate a Migration
```bash
alembic revision --autogenerate -m "add bio to user"
```

### 4. Example Alembic Migration Output ([alembic/versions/xxxx_add_bio_to_user.py](../../alembic/versions/))
```python
def upgrade():
    op.add_column('users', sa.Column('bio', sa.String(), nullable=True))
def downgrade():
    op.drop_column('users', 'bio')
```

### 5. Apply the Migration
```bash
alembic upgrade head
```

### 6. Use the New Field via API
```bash
curl -X PUT "http://localhost:8000/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"bio": "I love FastAPI!"}'
```

---

## Migration Process Diagram

```mermaid
flowchart LR
  A[Edit Model/Schema] --> B[Generate Migration]
  B --> C[Review Migration File]
  C --> D[Apply Migration]
  D --> E[Database Updated]
```

---

## Making a Database Change (Step-by-Step)

Suppose you want to add a new field (e.g., `bio`) to the User model. Hereâ€™s how you do it:

1. **Add the new field to the SQLAlchemy model** (`app/models/models.py`):
    ```python
    class User(Base, SoftDeleteMixin):
        # ... existing fields ...
        bio = Column(String, nullable=True)
    ```
2. **Update the schema** (`app/schemas/user.py`):
    ```python
    class UserUpdate(BaseModel):
        bio: Optional[str] = None
    ```
3. **Generate a migration**:
    ```bash
    alembic revision --autogenerate -m "add bio to user"
    ```
    - *Autogenerate* is great for most changes, but for complex operations (splitting tables, data migrations), you may want to hand-write the migration for full control.
4. **Review the migration file** (`alembic/versions/xxxx_add_bio_to_user.py`):
    ```python
    def upgrade():
        op.add_column('users', sa.Column('bio', sa.String(), nullable=True))
    def downgrade():
        op.drop_column('users', 'bio')
    ```
5. **Apply the migration**:
    ```bash
    alembic upgrade head
    ```
6. **Test the change**: Use the API or Python shell to confirm the new field works as expected.

> **CI/CD Note:**
> In production, migrations are usually applied automatically as part of your CI/CD pipeline (see deployment docs for details).

---

## Why Generate vs. Hand-Write a Migration?
- **Autogenerate**: Fast, safe for most schema changes (add/remove columns, simple types)
- **Hand-write**: Needed for complex changes (data migrations, renames, splitting tables, custom SQL)
- Always review autogenerated migrations before applying!

---

## Basic Database Operations

### Creating Data (INSERT)

To create a new user:

```python
# Using the API
POST /api/v1/auth/register
{
    "email": "newuser@example.com",
    "username": "newuser",
    "password": "SecurePassword123!"
}

# Using Python code
from app.crud.user import create_user_sync
from app.schemas.user import UserCreate

user_data = UserCreate(
    email="newuser@example.com",
    username="newuser",
    password="SecurePassword123!"
)
new_user = create_user_sync(db, user_data)
```

### Reading Data (SELECT)

To get user information:

```python
# Get current user
GET /api/v1/users/me

# Get user by ID
GET /api/v1/users/{user_id}

# Get all users (with pagination)
GET /api/v1/users?page=1&size=10
```

### Updating Data (UPDATE)

To update user information:

```python
# Update current user
PUT /api/v1/users/me
{
    "username": "newusername"
}

# Change password
POST /api/v1/auth/change-password
{
    "current_password": "OldPassword123!",
    "new_password": "NewPassword123!"
}
```

### Deleting Data (Soft Delete)

The template uses "soft delete" - data is hidden but not permanently removed:

```python
# Request account deletion
POST /api/v1/auth/request-account-deletion

# Confirm deletion (7-day grace period)
POST /api/v1/auth/confirm-account-deletion
{
    "token": "deletion_token_from_email"
}
```

---

## Advanced Database Features

### Search and Filter

The template includes powerful search and filtering capabilities:

```python
# Search users by name or email
GET /api/v1/users?search=john

# Filter by verification status
GET /api/v1/users?is_verified=true

# Combine search and filters
GET /api/v1/users?search=admin&is_superuser=true&page=1&size=20

# Sort results
GET /api/v1/users?sort_by=date_created&sort_order=desc
```

**Available filters:**
- `search`: Text search across multiple fields
- `is_verified`: Filter by email verification status
- `is_superuser`: Filter by admin status
- `oauth_provider`: Filter by login method
- `date_created`: Filter by creation date
- `is_deleted`: Filter by soft-deleted status (admin only)

> **Tip:** Filtering by `date_created` is useful for analytics and reporting. Filtering by `is_deleted` lets you view or restore soft-deleted records (admin endpoints only).

### Pagination

Handle large datasets efficiently:

```python
# Basic pagination
GET /api/v1/users?page=1&size=10

# Response includes pagination info
{
    "items": [...],
    "total": 150,
    "page": 1,
    "size": 10,
    "pages": 15,
    "has_next": true,
    "has_prev": false,
    "links": {
        "next": "/api/v1/users?page=2&size=10",
        "prev": null,
        "first": "/api/v1/users?page=1&size=10",
        "last": "/api/v1/users?page=15&size=10"
    }
}
```

### Audit Logging

Track all data changes automatically:

```python
# Audit logs are created automatically for:
# - User registration
# - Login attempts (success/failure)
# - Password changes
# - Account deletions
# - OAuth logins

# View audit logs (admin only)
GET /api/v1/admin/audit-logs?user_id=123&action=login&page=1&size=50
```

---

## Database Migrations

### What are Migrations?

Migrations are like a version control system for your database. They let you:
- **Track changes**: Keep history of database modifications
- **Roll back**: Undo changes if something goes wrong
- **Collaborate**: Share database changes with your team
- **Deploy safely**: Update production databases without losing data

### Creating a Migration

To add a new field to the User table:

```bash
alembic revision --autogenerate -m "Add phone number to users"

# This creates a file like: alembic/versions/abc123_add_phone_number.py
```

> **Reminder:** Alembic's `autogenerate` will NOT detect changes that only affect indexes, constraints, or some column types. If you add or change an index (e.g., `Index`, `UniqueConstraint`), you must manually edit the migration file to include those changes. Always review autogenerated migrations and add missing operations as needed!

### Running Migrations

```bash
# Apply all pending migrations
alembic upgrade head

# Roll back one migration
alembic downgrade -1

# Check current migration status
alembic current

# View migration history
alembic history
```

### Example Migration

Here's what a migration file looks like:

```python
# alembic/versions/abc123_add_phone_number.py
"""Add phone number to users

Revision ID: abc123def456
Revises: previous_migration_id
Create Date: 2024-01-15 10:30:00.000000

"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    # Add phone_number column to users table
    op.add_column('users', sa.Column('phone_number', sa.String(), nullable=True))

def downgrade():
    # Remove phone_number column if we need to roll back
    op.drop_column('users', 'phone_number')
```

---

## Configuration

### Environment Variables

Set these in your `.env` file:

```env
# Database connection
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# Connection pool settings
DB_POOL_SIZE=20
DB_MAX_OVERFLOW=30
DB_POOL_RECYCLE=3600
DB_POOL_TIMEOUT=30
DB_POOL_PRE_PING=true
```

### Connection Pooling

The template uses connection pooling for better performance:

- **Pool Size**: Number of database connections to keep open
- **Max Overflow**: Additional connections when pool is full
- **Pool Recycle**: How often to refresh connections (1 hour)
- **Pool Timeout**: How long to wait for a connection (30 seconds)
- **Pool Pre-ping**: Test connections before using them

---

## Testing Database Operations

### Using the API

Test database operations through the API:

```bash
# 1. Create a user
curl -X POST "http://localhost:8000/api/v1/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "username": "testuser",
    "password": "TestPassword123!"
  }'

# 2. Login to get access token
curl -X POST "http://localhost:8000/api/v1/auth/login" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=test@example.com&password=TestPassword123!"

# 3. Get user data
curl -X GET "http://localhost:8000/api/v1/users/me" \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# 4. Search users
curl -X GET "http://localhost:8000/api/v1/users?search=test&page=1&size=10"
```

### Using Python Code

Test database operations directly:

```python
from app.database.database import get_db
from app.crud.user import get_user_by_email_sync

# Get database session
db = next(get_db())

# Find user by email
user = get_user_by_email_sync(db, "test@example.com")
print(f"Found user: {user.username}")

# Close database session
db.close()
```

---

## Glossary

- **Schema**: A Pydantic model that defines the shape of data for validation and serialization.
- **CRUD**: Create, Read, Update, Delete (basic database operations).
- **Migration**: A script that changes the database schema (structure).
- **Alembic**: A tool for managing database migrations in SQLAlchemy projects.
- **ORM**: Object-Relational Mapper, a tool that lets you interact with the database using Python classes (e.g., SQLAlchemy).
- **Soft Delete**: Marking a record as deleted without actually removing it from the database.

---

## Next Steps

Now that you understand database management, you can:
1. **Add custom models**: Create new data types for your app
2. **Implement relationships**: Connect different types of data
3. **Add database indexes**: Improve query performance
4. **Set up monitoring**: Track database performance
5. **Create data exports**: Backup and export functionality

The database system is designed to be robust, scalable, and easy to work with. It handles the complex parts so you can focus on your application's features! 